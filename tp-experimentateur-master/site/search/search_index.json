{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tp Exp\u00e9rimentations \u00c9tat du TP Les 3 strat\u00e9gies marchent mais pour la troisi\u00e8me \u00e0 souvent le plus de comparaison ce qui est je pense d\u00fb au fait qu'il compte aussi le nombre de comparaison dans le tris de la liste des markeurs et celui du tris de la liste des positifs. R\u00e9ponses aux questions Question 1.2.2 Pour \u00e9tudier la complexit\u00e9 de cet algorithme il faut compter le nombre de comparaison entre l'ensemble des \u00e9lements de markers et les \u00e9lements de positif. Question 1.2.3 Non, car dans tous les cas il faudra parcourir tous les markers. Question 1.2.4 c1(m,p)=m*p Question 1.3.2 Non, il n'y a pas de pire des cas, car il faut parcourir tous les \u00e9l\u00e9ments de la liste markers et les comparer au premier \u00e9l\u00e9ment de la liste positive. Borne sup\u00e9rieure c2(m,p) = m Question 1.4.2 Oui, il y'a un pire des cas, c'est lorsqu'il n'y a pas d'\u00e9l\u00e9ment n\u00e9gatif dans markers donc il faudra parcourir tout le tableau marker. Borne sup\u00e9rieure c3(m,p)= Question 2.4.3 Q6 Inclusiond des fichiers photos Images Pour 10 markers on a: .. image:: ../images/tp1-10.png :scale: 50 % :align: center Pour 20 markers on a: .. image:: ../images/tp1-20.png :scale: 50 % :align: center Pour 30 markers on a: .. image:: ../images/tp1-30.png :scale: 50 % :align: center Pour 40 markers on a: .. image:: ../images/tp1-40.png :scale: 50 % :align: center Pour 50 markers on a: .. image:: ../images/tp1-50.png :scale: 50 % :align: center Pour 60 markers on a: .. image:: ../images/tp1-60.png :scale: 50 % :align: center Pour 70 markers on a: .. image:: ../images/tp1-70.png :scale: 50 % :align: center Pour 80 markers on a: .. image:: ../images/tp1-80.png :scale: 50 % :align: center Pour 90 markers on a: .. image:: ../images/tp1-90.png :scale: 50 % :align: center Pour 100 markers on a: .. image:: ../images/tp1-100.png :scale: 50 % :align: center","title":"Rendu"},{"location":"#tp-experimentations","text":"","title":"Tp Exp\u00e9rimentations"},{"location":"#etat-du-tp","text":"Les 3 strat\u00e9gies marchent mais pour la troisi\u00e8me \u00e0 souvent le plus de comparaison ce qui est je pense d\u00fb au fait qu'il compte aussi le nombre de comparaison dans le tris de la liste des markeurs et celui du tris de la liste des positifs.","title":"\u00c9tat du TP"},{"location":"#reponses-aux-questions","text":"","title":"R\u00e9ponses aux questions"},{"location":"#question-122","text":"Pour \u00e9tudier la complexit\u00e9 de cet algorithme il faut compter le nombre de comparaison entre l'ensemble des \u00e9lements de markers et les \u00e9lements de positif.","title":"Question 1.2.2"},{"location":"#question-123","text":"Non, car dans tous les cas il faudra parcourir tous les markers.","title":"Question 1.2.3"},{"location":"#question-124","text":"c1(m,p)=m*p","title":"Question  1.2.4"},{"location":"#question-132","text":"Non, il n'y a pas de pire des cas, car il faut parcourir tous les \u00e9l\u00e9ments de la liste markers et les comparer au premier \u00e9l\u00e9ment de la liste positive. Borne sup\u00e9rieure c2(m,p) = m","title":"Question 1.3.2"},{"location":"#question-142","text":"Oui, il y'a un pire des cas, c'est lorsqu'il n'y a pas d'\u00e9l\u00e9ment n\u00e9gatif dans markers donc il faudra parcourir tout le tableau marker. Borne sup\u00e9rieure c3(m,p)=","title":"Question 1.4.2"},{"location":"#question-243","text":"","title":"Question 2.4.3"},{"location":"#q6-inclusiond-des-fichiers-photos","text":"","title":"Q6 Inclusiond des fichiers photos"},{"location":"#images","text":"Pour 10 markers on a: .. image:: ../images/tp1-10.png :scale: 50 % :align: center Pour 20 markers on a: .. image:: ../images/tp1-20.png :scale: 50 % :align: center Pour 30 markers on a: .. image:: ../images/tp1-30.png :scale: 50 % :align: center Pour 40 markers on a: .. image:: ../images/tp1-40.png :scale: 50 % :align: center Pour 50 markers on a: .. image:: ../images/tp1-50.png :scale: 50 % :align: center Pour 60 markers on a: .. image:: ../images/tp1-60.png :scale: 50 % :align: center Pour 70 markers on a: .. image:: ../images/tp1-70.png :scale: 50 % :align: center Pour 80 markers on a: .. image:: ../images/tp1-80.png :scale: 50 % :align: center Pour 90 markers on a: .. image:: ../images/tp1-90.png :scale: 50 % :align: center Pour 100 markers on a: .. image:: ../images/tp1-100.png :scale: 50 % :align: center","title":"Images"},{"location":"experience/","text":"Experience module Module to manage experiences An experience is made of a set of markers and a subset of those markers that have been tested positive. Author Dpt Informatique - FST - Univ. Lille 2018, january Experience Source code in src/experience.py class Experience : def __init__ ( self , p , m ): \"\"\" Creates the results of an experience on `p` positive markers among `m` markers. Args: p (int): The number of positive markers (must be less or equal than the numbers of markers in `m`) m (int): The number of markers (must be greater than 0) \"\"\" assert ( p <= m ) self . markers = marker . Marker . markers ( m ) l = list ( self . markers ) random . shuffle ( l ) self . experience = l [ 0 : p ] def get_markers ( self ): \"\"\" Returns: Array of Marker: The markers that have been tested during the experience. Examples: >>> e = Experience(6,10) >>> m = e.get_markers() >>> len(m) 10 >>> sorted([ repr(i) for i in m]) ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9'] \"\"\" return self . markers def get_positive_markers ( self ): \"\"\" Returns: Array of Marker: The positive markers. Examples: >>> e = Experience(10,100) >>> p = e.get_positive_markers() >>> len(p) 10 \"\"\" return self . experience __init__ ( self , p , m ) special Creates the results of an experience on p positive markers among m markers. Parameters: Name Type Description Default p int The number of positive markers (must be less or equal than the numbers of markers in m ) required m int The number of markers (must be greater than 0) required Source code in src/experience.py def __init__ ( self , p , m ): \"\"\" Creates the results of an experience on `p` positive markers among `m` markers. Args: p (int): The number of positive markers (must be less or equal than the numbers of markers in `m`) m (int): The number of markers (must be greater than 0) \"\"\" assert ( p <= m ) self . markers = marker . Marker . markers ( m ) l = list ( self . markers ) random . shuffle ( l ) self . experience = l [ 0 : p ] get_markers ( self ) Returns: Type Description Array of Marker The markers that have been tested during the experience. Examples: >>> e = Experience ( 6 , 10 ) >>> m = e . get_markers () >>> len ( m ) 10 >>> sorted ([ repr ( i ) for i in m ]) [ 'm0' , 'm1' , 'm2' , 'm3' , 'm4' , 'm5' , 'm6' , 'm7' , 'm8' , 'm9' ] Source code in src/experience.py def get_markers ( self ): \"\"\" Returns: Array of Marker: The markers that have been tested during the experience. Examples: >>> e = Experience(6,10) >>> m = e.get_markers() >>> len(m) 10 >>> sorted([ repr(i) for i in m]) ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9'] \"\"\" return self . markers get_positive_markers ( self ) Returns: Type Description Array of Marker The positive markers. Examples: >>> e = Experience ( 10 , 100 ) >>> p = e . get_positive_markers () >>> len ( p ) 10 Source code in src/experience.py def get_positive_markers ( self ): \"\"\" Returns: Array of Marker: The positive markers. Examples: >>> e = Experience(10,100) >>> p = e.get_positive_markers() >>> len(p) 10 \"\"\" return self . experience","title":"Experience documentation"},{"location":"experience/#experience-module","text":"Module to manage experiences An experience is made of a set of markers and a subset of those markers that have been tested positive. Author Dpt Informatique - FST - Univ. Lille 2018, january","title":"Experience module"},{"location":"experience/#experience.Experience","text":"Source code in src/experience.py class Experience : def __init__ ( self , p , m ): \"\"\" Creates the results of an experience on `p` positive markers among `m` markers. Args: p (int): The number of positive markers (must be less or equal than the numbers of markers in `m`) m (int): The number of markers (must be greater than 0) \"\"\" assert ( p <= m ) self . markers = marker . Marker . markers ( m ) l = list ( self . markers ) random . shuffle ( l ) self . experience = l [ 0 : p ] def get_markers ( self ): \"\"\" Returns: Array of Marker: The markers that have been tested during the experience. Examples: >>> e = Experience(6,10) >>> m = e.get_markers() >>> len(m) 10 >>> sorted([ repr(i) for i in m]) ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9'] \"\"\" return self . markers def get_positive_markers ( self ): \"\"\" Returns: Array of Marker: The positive markers. Examples: >>> e = Experience(10,100) >>> p = e.get_positive_markers() >>> len(p) 10 \"\"\" return self . experience","title":"Experience"},{"location":"experience/#experience.Experience.__init__","text":"Creates the results of an experience on p positive markers among m markers. Parameters: Name Type Description Default p int The number of positive markers (must be less or equal than the numbers of markers in m ) required m int The number of markers (must be greater than 0) required Source code in src/experience.py def __init__ ( self , p , m ): \"\"\" Creates the results of an experience on `p` positive markers among `m` markers. Args: p (int): The number of positive markers (must be less or equal than the numbers of markers in `m`) m (int): The number of markers (must be greater than 0) \"\"\" assert ( p <= m ) self . markers = marker . Marker . markers ( m ) l = list ( self . markers ) random . shuffle ( l ) self . experience = l [ 0 : p ]","title":"__init__()"},{"location":"experience/#experience.Experience.get_markers","text":"Returns: Type Description Array of Marker The markers that have been tested during the experience. Examples: >>> e = Experience ( 6 , 10 ) >>> m = e . get_markers () >>> len ( m ) 10 >>> sorted ([ repr ( i ) for i in m ]) [ 'm0' , 'm1' , 'm2' , 'm3' , 'm4' , 'm5' , 'm6' , 'm7' , 'm8' , 'm9' ] Source code in src/experience.py def get_markers ( self ): \"\"\" Returns: Array of Marker: The markers that have been tested during the experience. Examples: >>> e = Experience(6,10) >>> m = e.get_markers() >>> len(m) 10 >>> sorted([ repr(i) for i in m]) ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9'] \"\"\" return self . markers","title":"get_markers()"},{"location":"experience/#experience.Experience.get_positive_markers","text":"Returns: Type Description Array of Marker The positive markers. Examples: >>> e = Experience ( 10 , 100 ) >>> p = e . get_positive_markers () >>> len ( p ) 10 Source code in src/experience.py def get_positive_markers ( self ): \"\"\" Returns: Array of Marker: The positive markers. Examples: >>> e = Experience(10,100) >>> p = e.get_positive_markers() >>> len(p) 10 \"\"\" return self . experience","title":"get_positive_markers()"},{"location":"marker/","text":"Marker module Module to manage markers A marker is a represented as a String. Author Dpt Informatique - FST - Univ. Lille 2018, january Marker Source code in src/marker.py class Marker : def __init__ ( self , number ): \"\"\" Creates a new Marker. Args: number (int): The number of the marker (must be greater or equal than zero) \"\"\" assert ( type ( number ) is int ) assert ( number >= 0 ) self . number = number def cmp ( self , other ): \"\"\" Compares this marker and `other`. Args: other (Marker): The first marker Returns: int: -1, 0 or 1 resp. if `self < other`, `self == other` or `self > other` Examples: >>> Marker(45).cmp(Marker(234)) -1 >>> Marker(45).cmp(Marker(45)) 0 >>> Marker(45).cmp(Marker(24)) 1 \"\"\" if self . number == other . number : return 0 elif self . number < other . number : return - 1 else : return 1 def __repr__ ( self ): return \"m {} \" . format ( self . number ) @staticmethod def markers ( p ): \"\"\" Returns a list of `p` markers. Markers are in a random order. Args: p (int): The number of markers (must be strictly greater than 0). Returns: list of String: The list of markers Examples: >>> import marker >>> sorted([\"{}\".format(i) for i in marker.Marker.markers(10)]) ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9'] \"\"\" assert ( p > 0 ) l = [ Marker ( i ) for i in range ( p ) ] random . shuffle ( l ) return l __init__ ( self , number ) special Creates a new Marker. Parameters: Name Type Description Default number int The number of the marker (must be greater or equal than zero) required Source code in src/marker.py def __init__ ( self , number ): \"\"\" Creates a new Marker. Args: number (int): The number of the marker (must be greater or equal than zero) \"\"\" assert ( type ( number ) is int ) assert ( number >= 0 ) self . number = number cmp ( self , other ) Compares this marker and other . Parameters: Name Type Description Default other Marker The first marker required Returns: Type Description int -1, 0 or 1 resp. if self < other , self == other or self > other Examples: >>> Marker ( 45 ) . cmp ( Marker ( 234 )) - 1 >>> Marker ( 45 ) . cmp ( Marker ( 45 )) 0 >>> Marker ( 45 ) . cmp ( Marker ( 24 )) 1 Source code in src/marker.py def cmp ( self , other ): \"\"\" Compares this marker and `other`. Args: other (Marker): The first marker Returns: int: -1, 0 or 1 resp. if `self < other`, `self == other` or `self > other` Examples: >>> Marker(45).cmp(Marker(234)) -1 >>> Marker(45).cmp(Marker(45)) 0 >>> Marker(45).cmp(Marker(24)) 1 \"\"\" if self . number == other . number : return 0 elif self . number < other . number : return - 1 else : return 1 markers ( p ) staticmethod Returns a list of p markers. Markers are in a random order. Parameters: Name Type Description Default p int The number of markers (must be strictly greater than 0). required Returns: Type Description list of String The list of markers Examples: >>> import marker >>> sorted ([ \" {} \" . format ( i ) for i in marker . Marker . markers ( 10 )]) [ 'm0' , 'm1' , 'm2' , 'm3' , 'm4' , 'm5' , 'm6' , 'm7' , 'm8' , 'm9' ] Source code in src/marker.py @staticmethod def markers ( p ): \"\"\" Returns a list of `p` markers. Markers are in a random order. Args: p (int): The number of markers (must be strictly greater than 0). Returns: list of String: The list of markers Examples: >>> import marker >>> sorted([\"{}\".format(i) for i in marker.Marker.markers(10)]) ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9'] \"\"\" assert ( p > 0 ) l = [ Marker ( i ) for i in range ( p ) ] random . shuffle ( l ) return l","title":"Marker documentation"},{"location":"marker/#marker-module","text":"Module to manage markers A marker is a represented as a String. Author Dpt Informatique - FST - Univ. Lille 2018, january","title":"Marker module"},{"location":"marker/#src.marker.Marker","text":"Source code in src/marker.py class Marker : def __init__ ( self , number ): \"\"\" Creates a new Marker. Args: number (int): The number of the marker (must be greater or equal than zero) \"\"\" assert ( type ( number ) is int ) assert ( number >= 0 ) self . number = number def cmp ( self , other ): \"\"\" Compares this marker and `other`. Args: other (Marker): The first marker Returns: int: -1, 0 or 1 resp. if `self < other`, `self == other` or `self > other` Examples: >>> Marker(45).cmp(Marker(234)) -1 >>> Marker(45).cmp(Marker(45)) 0 >>> Marker(45).cmp(Marker(24)) 1 \"\"\" if self . number == other . number : return 0 elif self . number < other . number : return - 1 else : return 1 def __repr__ ( self ): return \"m {} \" . format ( self . number ) @staticmethod def markers ( p ): \"\"\" Returns a list of `p` markers. Markers are in a random order. Args: p (int): The number of markers (must be strictly greater than 0). Returns: list of String: The list of markers Examples: >>> import marker >>> sorted([\"{}\".format(i) for i in marker.Marker.markers(10)]) ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9'] \"\"\" assert ( p > 0 ) l = [ Marker ( i ) for i in range ( p ) ] random . shuffle ( l ) return l","title":"Marker"},{"location":"marker/#src.marker.Marker.__init__","text":"Creates a new Marker. Parameters: Name Type Description Default number int The number of the marker (must be greater or equal than zero) required Source code in src/marker.py def __init__ ( self , number ): \"\"\" Creates a new Marker. Args: number (int): The number of the marker (must be greater or equal than zero) \"\"\" assert ( type ( number ) is int ) assert ( number >= 0 ) self . number = number","title":"__init__()"},{"location":"marker/#src.marker.Marker.cmp","text":"Compares this marker and other . Parameters: Name Type Description Default other Marker The first marker required Returns: Type Description int -1, 0 or 1 resp. if self < other , self == other or self > other Examples: >>> Marker ( 45 ) . cmp ( Marker ( 234 )) - 1 >>> Marker ( 45 ) . cmp ( Marker ( 45 )) 0 >>> Marker ( 45 ) . cmp ( Marker ( 24 )) 1 Source code in src/marker.py def cmp ( self , other ): \"\"\" Compares this marker and `other`. Args: other (Marker): The first marker Returns: int: -1, 0 or 1 resp. if `self < other`, `self == other` or `self > other` Examples: >>> Marker(45).cmp(Marker(234)) -1 >>> Marker(45).cmp(Marker(45)) 0 >>> Marker(45).cmp(Marker(24)) 1 \"\"\" if self . number == other . number : return 0 elif self . number < other . number : return - 1 else : return 1","title":"cmp()"},{"location":"marker/#src.marker.Marker.markers","text":"Returns a list of p markers. Markers are in a random order. Parameters: Name Type Description Default p int The number of markers (must be strictly greater than 0). required Returns: Type Description list of String The list of markers Examples: >>> import marker >>> sorted ([ \" {} \" . format ( i ) for i in marker . Marker . markers ( 10 )]) [ 'm0' , 'm1' , 'm2' , 'm3' , 'm4' , 'm5' , 'm6' , 'm7' , 'm8' , 'm9' ] Source code in src/marker.py @staticmethod def markers ( p ): \"\"\" Returns a list of `p` markers. Markers are in a random order. Args: p (int): The number of markers (must be strictly greater than 0). Returns: list of String: The list of markers Examples: >>> import marker >>> sorted([\"{}\".format(i) for i in marker.Marker.markers(10)]) ['m0', 'm1', 'm2', 'm3', 'm4', 'm5', 'm6', 'm7', 'm8', 'm9'] \"\"\" assert ( p > 0 ) l = [ Marker ( i ) for i in range ( p ) ] random . shuffle ( l ) return l","title":"markers()"},{"location":"sorting/","text":"Sorting module Sorting functions module for experience assignment Author Dpt Informatique - FST - Univ. Lille 2018, january merge ( t1 , t2 , cmp ) Given two sorted lists, creates a fresh sorted list. Parameters: Name Type Description Default t1 list A list of objects required t2 list A list of objects required cmp function A comparison function, returning 0 if a == b, -1 is a < b, 1 if a > b required Complexity Time complexity of merge is \\(O(n_1+n_2)\\) with \\(n_1\\) and \\(n_2\\) resp. the length of t1 and t2 Returns: Type Description list A fresh list, sorted. Examples: >>> def cmp ( x , y ): ... if x == y : ... return 0 ... elif x < y : ... return - 1 ... else : ... return 1 >>> t1 = [ 0 , 2 , 5 , 6 ] >>> t2 = [ 1 , 3 , 4 ] >>> merge ( t1 , t2 , cmp ) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] Source code in src/sorting.py def merge ( t1 , t2 , cmp ): \"\"\" Given two sorted lists, creates a fresh sorted list. Args: t1 (list): A list of objects t2 (list): A list of objects cmp (function): A comparison function, returning 0 if a == b, -1 is a < b, 1 if a > b Note: Complexity Time complexity of merge is $O(n_1+n_2)$ with $n_1$ and $n_2$ resp. the length of `t1` and `t2` Returns: list: A fresh list, sorted. Examples: >>> def cmp (x,y): ... if x == y: ... return 0 ... elif x < y: ... return -1 ... else: ... return 1 >>> t1 = [0,2,5,6] >>> t2 = [1,3,4] >>> merge(t1,t2,cmp) [0, 1, 2, 3, 4, 5, 6] \"\"\" n1 = len ( t1 ) n2 = len ( t2 ) t = [ 0 for i in range ( n1 + n2 )] i = j = k = 0 while i < n1 and j < n2 : if cmp ( t1 [ i ], t2 [ j ]) < 0 : t [ k ] = t1 [ i ] i = i + 1 else : t [ k ] = t2 [ j ] j = j + 1 k = k + 1 while i < n1 : t [ k ] = t1 [ i ] i = i + 1 k = k + 1 while j < n2 : t [ k ] = t2 [ j ] j = j + 1 k = k + 1 return t merge_sort ( t , cmp ) A sorting function implementing the merge sort algorithm. Parameters: Name Type Description Default t list A list of integers required cmp function A comparison function, returning 0 if a == b, -1 is a < b, 1 if a > b required Complexity Time complexity of merge is \\(O(n_1+n_2)\\) with \\(n_1\\) and \\(n_2\\) resp. the length of t1 and t2 Returns: Type Description list A fresh list, sorted. Examples: >>> import marker >>> def cmp ( x , y ): ... return x . cmp ( y ) >>> t = marker . Marker . markers ( 10 ) >>> merge_sort ( t , cmp ) [ m0 , m1 , m2 , m3 , m4 , m5 , m6 , m7 , m8 , m9 ] Source code in src/sorting.py def merge_sort ( t , cmp ): \"\"\" A sorting function implementing the merge sort algorithm. Args: t (list): A list of integers cmp (function): A comparison function, returning 0 if a == b, -1 is a < b, 1 if a > b Note: Complexity Time complexity of merge is $O(n_1+n_2)$ with $n_1$ and $n_2$ resp. the length of `t1` and `t2` Returns: list: A fresh list, sorted. Examples: >>> import marker >>> def cmp (x,y): ... return x.cmp(y) >>> t = marker.Marker.markers(10) >>> merge_sort(t,cmp) [m0, m1, m2, m3, m4, m5, m6, m7, m8, m9] \"\"\" n = len ( t ) if n <= 1 : # cas de base return copy . deepcopy ( t ) else : # cas general t1 = merge_sort (( t [ 0 :(( n - 1 ) // 2 + 1 )]), cmp ) t2 = merge_sort (( t [(( n - 1 ) // 2 + 1 ): n ]), cmp ) return merge ( t1 , t2 , cmp )","title":"Sorting documentation"},{"location":"sorting/#sorting-module","text":"Sorting functions module for experience assignment Author Dpt Informatique - FST - Univ. Lille 2018, january","title":"Sorting module"},{"location":"sorting/#src.sorting.merge","text":"Given two sorted lists, creates a fresh sorted list. Parameters: Name Type Description Default t1 list A list of objects required t2 list A list of objects required cmp function A comparison function, returning 0 if a == b, -1 is a < b, 1 if a > b required Complexity Time complexity of merge is \\(O(n_1+n_2)\\) with \\(n_1\\) and \\(n_2\\) resp. the length of t1 and t2 Returns: Type Description list A fresh list, sorted. Examples: >>> def cmp ( x , y ): ... if x == y : ... return 0 ... elif x < y : ... return - 1 ... else : ... return 1 >>> t1 = [ 0 , 2 , 5 , 6 ] >>> t2 = [ 1 , 3 , 4 ] >>> merge ( t1 , t2 , cmp ) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 ] Source code in src/sorting.py def merge ( t1 , t2 , cmp ): \"\"\" Given two sorted lists, creates a fresh sorted list. Args: t1 (list): A list of objects t2 (list): A list of objects cmp (function): A comparison function, returning 0 if a == b, -1 is a < b, 1 if a > b Note: Complexity Time complexity of merge is $O(n_1+n_2)$ with $n_1$ and $n_2$ resp. the length of `t1` and `t2` Returns: list: A fresh list, sorted. Examples: >>> def cmp (x,y): ... if x == y: ... return 0 ... elif x < y: ... return -1 ... else: ... return 1 >>> t1 = [0,2,5,6] >>> t2 = [1,3,4] >>> merge(t1,t2,cmp) [0, 1, 2, 3, 4, 5, 6] \"\"\" n1 = len ( t1 ) n2 = len ( t2 ) t = [ 0 for i in range ( n1 + n2 )] i = j = k = 0 while i < n1 and j < n2 : if cmp ( t1 [ i ], t2 [ j ]) < 0 : t [ k ] = t1 [ i ] i = i + 1 else : t [ k ] = t2 [ j ] j = j + 1 k = k + 1 while i < n1 : t [ k ] = t1 [ i ] i = i + 1 k = k + 1 while j < n2 : t [ k ] = t2 [ j ] j = j + 1 k = k + 1 return t","title":"merge()"},{"location":"sorting/#src.sorting.merge_sort","text":"A sorting function implementing the merge sort algorithm. Parameters: Name Type Description Default t list A list of integers required cmp function A comparison function, returning 0 if a == b, -1 is a < b, 1 if a > b required Complexity Time complexity of merge is \\(O(n_1+n_2)\\) with \\(n_1\\) and \\(n_2\\) resp. the length of t1 and t2 Returns: Type Description list A fresh list, sorted. Examples: >>> import marker >>> def cmp ( x , y ): ... return x . cmp ( y ) >>> t = marker . Marker . markers ( 10 ) >>> merge_sort ( t , cmp ) [ m0 , m1 , m2 , m3 , m4 , m5 , m6 , m7 , m8 , m9 ] Source code in src/sorting.py def merge_sort ( t , cmp ): \"\"\" A sorting function implementing the merge sort algorithm. Args: t (list): A list of integers cmp (function): A comparison function, returning 0 if a == b, -1 is a < b, 1 if a > b Note: Complexity Time complexity of merge is $O(n_1+n_2)$ with $n_1$ and $n_2$ resp. the length of `t1` and `t2` Returns: list: A fresh list, sorted. Examples: >>> import marker >>> def cmp (x,y): ... return x.cmp(y) >>> t = marker.Marker.markers(10) >>> merge_sort(t,cmp) [m0, m1, m2, m3, m4, m5, m6, m7, m8, m9] \"\"\" n = len ( t ) if n <= 1 : # cas de base return copy . deepcopy ( t ) else : # cas general t1 = merge_sort (( t [ 0 :(( n - 1 ) // 2 + 1 )]), cmp ) t2 = merge_sort (( t [(( n - 1 ) // 2 + 1 ): n ]), cmp ) return merge ( t1 , t2 , cmp )","title":"merge_sort()"},{"location":"test/","text":"Test module Test module for experiences assignment Author Dpt Informatique - FST - Univ. Lille 2018, january compare ( m1 , m2 ) Compares two markers Parameters: Name Type Description Default m1 Marker A marker required m2 Marker Another marker required Returns: Type Description int -1 if m1 < m2 , 0 if m1 = m2 or 1 when m1 > m2 Source code in src/test.py def compare ( m1 , m2 ): ''' Compares two markers Args: m1 (Marker): A marker m2 (Marker): Another marker Returns: int: -1 if `m1 < m2`, 0 if `m1 = m2` or 1 when `m1 > m2` ''' global cpt cpt += 1 return m1 . cmp ( m2 ) negative_markers1 ( markers , positive ) Computes the list of negative markers from the list of markers and the list of positive markers. Parameters: Name Type Description Default markers list of str The list of markers required positive list of str The list of positive markers required Returns: Type Description list of str The list of negative markers Source code in src/test.py def negative_markers1 ( markers , positive ): \"\"\" Computes the list of negative markers from the list of markers and the list of positive markers. Args: markers (list of str): The list of markers positive (list of str): The list of positive markers Returns: list of str: The list of negative markers \"\"\" negative = [] for m in markers : k = 0 while k < len ( positive ) and compare ( m , positive [ k ]) != 0 : k += 1 if k == len ( positive ): negative . append ( m ) return negative","title":"Test module"},{"location":"test/#test-module","text":"Test module for experiences assignment Author Dpt Informatique - FST - Univ. Lille 2018, january","title":"Test module"},{"location":"test/#src.test.compare","text":"Compares two markers Parameters: Name Type Description Default m1 Marker A marker required m2 Marker Another marker required Returns: Type Description int -1 if m1 < m2 , 0 if m1 = m2 or 1 when m1 > m2 Source code in src/test.py def compare ( m1 , m2 ): ''' Compares two markers Args: m1 (Marker): A marker m2 (Marker): Another marker Returns: int: -1 if `m1 < m2`, 0 if `m1 = m2` or 1 when `m1 > m2` ''' global cpt cpt += 1 return m1 . cmp ( m2 )","title":"compare()"},{"location":"test/#src.test.negative_markers1","text":"Computes the list of negative markers from the list of markers and the list of positive markers. Parameters: Name Type Description Default markers list of str The list of markers required positive list of str The list of positive markers required Returns: Type Description list of str The list of negative markers Source code in src/test.py def negative_markers1 ( markers , positive ): \"\"\" Computes the list of negative markers from the list of markers and the list of positive markers. Args: markers (list of str): The list of markers positive (list of str): The list of positive markers Returns: list of str: The list of negative markers \"\"\" negative = [] for m in markers : k = 0 while k < len ( positive ) and compare ( m , positive [ k ]) != 0 : k += 1 if k == len ( positive ): negative . append ( m ) return negative","title":"negative_markers1()"}]}